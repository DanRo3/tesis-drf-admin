# apps/chat/tools.py
import requests
import json
import logging
import base64
import uuid
import re # Para extraer extensión del header Base64
from django.conf import settings
from django.core.files.base import ContentFile
import os
# Importar default_storage para guardar directamente si no se usa un modelo temporal
# from django.core.files.storage import default_storage
from langchain.tools import tool
# Necesitarás tu modelo Message para asignarle el ImageField si guardas a través de él
# o decides no hacerlo y solo devolver la ruta.
# Por ahora, asumiremos que la vista que llama a esto se encargará de asociar
# la ruta de la imagen con el mensaje final del asistente.
# O, si el tool crea el mensaje, necesitaríamos Message aquí.
# Para desacoplar, la herramienta solo guardará el archivo y devolverá su ruta.

logger = logging.getLogger(__name__)

MAS_API_URL = getattr(settings, "MAS_API_URL", None)
MAS_QUERY_ENDPOINT = "/api/query"
# El directorio donde la herramienta guardará las imágenes, relativo a MEDIA_ROOT
# Coincide con el upload_to de tu ImageField en el modelo Message
# (e.g., si upload_to="chat_mas_images/")
MAS_IMAGE_UPLOAD_SUBDIR = getattr(settings, "MAS_IMAGE_UPLOAD_SUBDIR", "chat_images")


@tool
def query_historical_data_system(user_query: str) -> str:
    """
    Use this tool ONLY for specific user queries about historical maritime data...
    The tool will return a JSON string. If an image is generated by the MAS, this tool
    will save it and the JSON will contain an 'image_path' key with the relative
    path to the saved image. Otherwise, 'image_path' will be null.
    """
    logger.info(f"Tool 'query_historical_data_system' invoked with query: '{user_query}'")
    if not MAS_API_URL:
        # ... (manejo de error como antes) ...
        return json.dumps({"error": "Configuración incorrecta: El servicio de datos históricos no está disponible.", "text_response": None, "image_path": None})

    full_url = MAS_API_URL.rstrip('/') + MAS_QUERY_ENDPOINT
    headers = {"Content-Type": "application/json"}
    payload = {"query": user_query}

    final_mas_response = {
        "text_response": None,
        "image_path": None, # Cambiado de image_response a image_path
        "error": None
    }

    try:
        logger.debug(f"Enviando POST a MAS: {full_url} con payload: {payload}")
        response = requests.post(full_url, headers=headers, json=payload, timeout=60)
        response.raise_for_status()

        try:
            mas_data = response.json()
            logger.debug(f"Respuesta JSON cruda del MAS: {mas_data}")

            # Asignar texto y error del MAS si existen
            final_mas_response["text_response"] = mas_data.get("text_response")
            final_mas_response["error"] = mas_data.get("error") # Error lógico del MAS

            mas_base64_image = mas_data.get("image_response")

            if mas_base64_image:
                logger.info("Base64 de imagen recibido del MAS. Intentando guardar como archivo...")
                try:
                    if isinstance(mas_base64_image, str) and ";base64," in mas_base64_image:
                        header, encoded_data = mas_base64_image.split(",", 1)
                        image_data_bytes = base64.b64decode(encoded_data)

                        extension = "png" # Default
                        mime_type_match = re.search(r"data:image/(\w+);base64", header)
                        if mime_type_match:
                            ext = mime_type_match.group(1).lower()
                            if ext in ['png', 'jpg', 'jpeg', 'gif', 'webp']: extension = ext

                        filename_only = f"mas_viz_{uuid.uuid4()}.{extension}"
                        # Ruta completa donde Django FileSystemStorage guardará
                        # (relativa a MEDIA_ROOT)
                        # Ejemplo: "chat_mas_images/mas_viz_uuid.png"
                        relative_file_path = os.path.join(MAS_IMAGE_UPLOAD_SUBDIR, filename_only)

                        # Usar Django's default storage para guardar el archivo
                        from django.core.files.storage import default_storage
                        saved_file_path = default_storage.save(relative_file_path, ContentFile(image_data_bytes))
                        # default_storage.save devuelve la ruta relativa donde se guardó
                        # (puede añadir sufijos si el archivo ya existe, aunque con UUID es improbable)

                        final_mas_response["image_path"] = saved_file_path # Guardar la ruta relativa
                        logger.info(f"Imagen del MAS guardada en: {saved_file_path}")
                        # El texto del MAS podría ser "Gráfico generado"
                        if not final_mas_response["text_response"]:
                             final_mas_response["text_response"] = "Se generó una visualización."

                    else:
                        logger.warning("Formato Base64 inesperado del MAS.")
                        final_mas_response["error"] = (final_mas_response["error"] or "") + " Error procesando formato de imagen."
                except Exception as img_e:
                    logger.exception(f"Error al guardar la imagen Base64 del MAS: {img_e}")
                    final_mas_response["error"] = (final_mas_response["error"] or "") + f" Error al procesar imagen: {str(img_e)}"
            
            # Si hubo un error del MAS, pero también texto, el texto podría explicar el error
            if final_mas_response["error"] and final_mas_response["text_response"] and final_mas_response["error"] in final_mas_response["text_response"]:
                pass # El error ya está en el texto
            elif final_mas_response["error"] and not final_mas_response["text_response"]:
                final_mas_response["text_response"] = f"Error del sistema de datos: {final_mas_response['error']}"


        except json.JSONDecodeError:
            logger.error(f"Fallo al decodificar JSON de MAS. Contenido: {response.text[:500]}...")
            final_mas_response["error"] = "El servicio de datos devolvió un formato inválido."
            final_mas_response["text_response"] = "Información no disponible (formato inesperado)."

        return json.dumps(final_mas_response)

    # ... (resto de los except para requests.exceptions como antes, pero actualizando final_mas_response) ...
    except requests.exceptions.Timeout:
        logger.error(f"Timeout (60s) al llamar al MAS en {full_url}")
        final_mas_response["error"] = "Servicio de datos tardó demasiado."
        final_mas_response["text_response"] = "Información no disponible (timeout)."
        return json.dumps(final_mas_response)
    except requests.exceptions.ConnectionError:
        logger.error(f"Error de conexión al llamar al MAS en {full_url}")
        final_mas_response["error"] = "No se pudo conectar al servicio de datos."
        final_mas_response["text_response"] = "Información no disponible (error de conexión)."
        return json.dumps(final_mas_response)
    except requests.exceptions.HTTPError as e:
        # ... (manejo como antes, actualizando final_mas_response) ...
        error_detail = e.response.text[:200] # Limitar longitud
        final_mas_response["error"] = f"Servicio de datos devolvió error HTTP {e.response.status_code}."
        final_mas_response["text_response"] = f"Información no disponible (error {e.response.status_code}): {error_detail}"
        return json.dumps(final_mas_response)
    except Exception as e:
        logger.exception(f"Error inesperado llamando al MAS: {e}")
        final_mas_response["error"] = f"Error inesperado contactando servicio de datos: {str(e)[:100]}"
        final_mas_response["text_response"] = "Información no disponible (error inesperado)."
        return json.dumps(final_mas_response)